<extensionManifest><systemApiVersion>1.12.0</systemApiVersion><extensions><extension><name>br.gov.sp.fazenda.processors.QueryDatabaseTable</name><type>PROCESSOR</type><deprecationNotice/><description>Generates a SQL select query, or uses a provided statement, and executes it to fetch all rows whose values in the specified Maximum Value column(s) are larger than the previously-seen maxima. Query result will be converted to Avro format. Expression Language is supported for several properties, but no incoming connections are permitted. The Variable Registry may be used to provide values for any property containing Expression Language. If it is desired to leverage flow file attributes to perform these queries, the GenerateTableFetch and/or ExecuteSQL processors can be used for this purpose. Streaming is used so arbitrarily large result sets are supported. This processor can be scheduled to run on a timer or cron expression, using the standard scheduling methods. This processor is intended to be run on the Primary Node only. FlowFile attribute 'querydbtable.row.count' indicates how many rows were selected.</description><tags><tag>sql</tag><tag>select</tag><tag>jdbc</tag><tag>query</tag><tag>database</tag></tags><properties><property><name>Database Connection Pooling Service</name><displayName>Database Connection Pooling Service</displayName><description>The Controller Service that is used to obtain a connection to the database.</description><defaultValue></defaultValue><controllerServiceDefinition><className>org.apache.nifi.dbcp.DBCPService</className><groupId>org.apache.nifi</groupId><artifactId>nifi-standard-services-api-nar</artifactId><version>1.12.0</version></controllerServiceDefinition><allowableValues></allowableValues><required>true</required><sensitive>false</sensitive><expressionLanguageSupported>false</expressionLanguageSupported><expressionLanguageScope>NONE</expressionLanguageScope><dynamicallyModifiesClasspath>false</dynamicallyModifiesClasspath><dynamic>false</dynamic></property><property><name>db-fetch-db-type</name><displayName>Database Type</displayName><description>The type/flavor of database, used for generating database-specific code. In many cases the Generic type should suffice, but some databases (such as Oracle) require custom SQL clauses. </description><defaultValue>Generic</defaultValue><allowableValues><allowableValue><displayName>Generic</displayName><value>Generic</value><description>Generates ANSI SQL</description></allowableValue><allowableValue><displayName>Oracle</displayName><value>Oracle</value><description>Generates Oracle compliant SQL</description></allowableValue><allowableValue><displayName>MS SQL 2012+</displayName><value>MS SQL 2012+</value><description>Generates MS SQL Compatible SQL, for version 2012 or greater</description></allowableValue><allowableValue><displayName>MySQL</displayName><value>MySQL</value><description>Generates MySQL compatible SQL</description></allowableValue></allowableValues><required>true</required><sensitive>false</sensitive><expressionLanguageSupported>false</expressionLanguageSupported><expressionLanguageScope>NONE</expressionLanguageScope><dynamicallyModifiesClasspath>false</dynamicallyModifiesClasspath><dynamic>false</dynamic></property><property><name>db-fetch-sql-query</name><displayName>Custom Query</displayName><description>A custom SQL query used to retrieve data. Instead of building a SQL query from other properties, this query will be wrapped as a sub-query. Query must have no ORDER BY statement.</description><defaultValue></defaultValue><allowableValues></allowableValues><required>false</required><sensitive>false</sensitive><expressionLanguageSupported>true</expressionLanguageSupported><expressionLanguageScope>VARIABLE_REGISTRY</expressionLanguageScope><dynamicallyModifiesClasspath>false</dynamicallyModifiesClasspath><dynamic>false</dynamic></property><property><name>qdbtr-record-writer</name><displayName>Record Writer</displayName><description>Specifies the Controller Service to use for writing results to a FlowFile. The Record Writer may use Inherit Schema to emulate the inferred schema behavior, i.e. an explicit schema need not be defined in the writer, and will be supplied by the same logic used to infer the schema from the column types.</description><defaultValue></defaultValue><controllerServiceDefinition><className>org.apache.nifi.serialization.RecordSetWriterFactory</className><groupId>org.apache.nifi</groupId><artifactId>nifi-standard-services-api-nar</artifactId><version>1.12.0</version></controllerServiceDefinition><allowableValues></allowableValues><required>true</required><sensitive>false</sensitive><expressionLanguageSupported>false</expressionLanguageSupported><expressionLanguageScope>NONE</expressionLanguageScope><dynamicallyModifiesClasspath>false</dynamicallyModifiesClasspath><dynamic>false</dynamic></property><property><name>Maximum-value Columns</name><displayName>Maximum-value Columns</displayName><description>A comma-separated list of column names. The processor will keep track of the maximum value for each column that has been returned since the processor started running. Using multiple columns implies an order to the column list, and each column's values are expected to increase more slowly than the previous columns' values. Thus, using multiple columns implies a hierarchical structure of columns, which is usually used for partitioning tables. This processor can be used to retrieve only those rows that have been added/updated since the last retrieval. Note that some JDBC types such as bit/boolean are not conducive to maintaining maximum value, so columns of these types should not be listed in this property, and will result in error(s) during processing. If no columns are provided, all rows from the table will be considered, which could have a performance impact. NOTE: It is important to use consistent max-value column names for a given table for incremental fetch to work properly.</description><defaultValue></defaultValue><allowableValues></allowableValues><required>false</required><sensitive>false</sensitive><expressionLanguageSupported>true</expressionLanguageSupported><expressionLanguageScope>FLOWFILE_ATTRIBUTES</expressionLanguageScope><dynamicallyModifiesClasspath>false</dynamicallyModifiesClasspath><dynamic>false</dynamic></property><property><name>Max Wait Time</name><displayName>Max Wait Time</displayName><description>The maximum amount of time allowed for a running SQL select query , zero means there is no limit. Max time less than 1 second will be equal to zero.</description><defaultValue>0 seconds</defaultValue><allowableValues></allowableValues><required>true</required><sensitive>false</sensitive><expressionLanguageSupported>true</expressionLanguageSupported><expressionLanguageScope>FLOWFILE_ATTRIBUTES</expressionLanguageScope><dynamicallyModifiesClasspath>false</dynamicallyModifiesClasspath><dynamic>false</dynamic></property><property><name>Fetch Size</name><displayName>Fetch Size</displayName><description>The number of result rows to be fetched from the result set at a time. This is a hint to the database driver and may not be honored and/or exact. If the value specified is zero, then the hint is ignored.</description><defaultValue>0</defaultValue><allowableValues></allowableValues><required>true</required><sensitive>false</sensitive><expressionLanguageSupported>true</expressionLanguageSupported><expressionLanguageScope>VARIABLE_REGISTRY</expressionLanguageScope><dynamicallyModifiesClasspath>false</dynamicallyModifiesClasspath><dynamic>false</dynamic></property><property><name>qdbt-max-rows</name><displayName>Max Rows Per Flow File</displayName><description>The maximum number of result rows that will be included in a single FlowFile. This will allow you to break up very large result sets into multiple FlowFiles. If the value specified is zero, then all rows are returned in a single FlowFile.</description><defaultValue>0</defaultValue><allowableValues></allowableValues><required>true</required><sensitive>false</sensitive><expressionLanguageSupported>true</expressionLanguageSupported><expressionLanguageScope>VARIABLE_REGISTRY</expressionLanguageScope><dynamicallyModifiesClasspath>false</dynamicallyModifiesClasspath><dynamic>false</dynamic></property><property><name>qdbt-output-batch-size</name><displayName>Output Batch Size</displayName><description>The number of output FlowFiles to queue before committing the process session. When set to zero, the session will be committed when all result set rows have been processed and the output FlowFiles are ready for transfer to the downstream relationship. For large result sets, this can cause a large burst of FlowFiles to be transferred at the end of processor execution. If this property is set, then when the specified number of FlowFiles are ready for transfer, then the session will be committed, thus releasing the FlowFiles to the downstream relationship. NOTE: The maxvalue.* and fragment.count attributes will not be set on FlowFiles when this property is set.</description><defaultValue>0</defaultValue><allowableValues></allowableValues><required>true</required><sensitive>false</sensitive><expressionLanguageSupported>true</expressionLanguageSupported><expressionLanguageScope>VARIABLE_REGISTRY</expressionLanguageScope><dynamicallyModifiesClasspath>false</dynamicallyModifiesClasspath><dynamic>false</dynamic></property><property><name>qdbt-max-frags</name><displayName>Maximum Number of Fragments</displayName><description>The maximum number of fragments. If the value specified is zero, then all fragments are returned. This prevents OutOfMemoryError when this processor ingests huge table. NOTE: Setting this property can result in data loss, as the incoming results are not ordered, and fragments may end at arbitrary boundaries where rows are not included in the result set.</description><defaultValue>0</defaultValue><allowableValues></allowableValues><required>true</required><sensitive>false</sensitive><expressionLanguageSupported>true</expressionLanguageSupported><expressionLanguageScope>VARIABLE_REGISTRY</expressionLanguageScope><dynamicallyModifiesClasspath>false</dynamicallyModifiesClasspath><dynamic>false</dynamic></property><property><name>qdbtr-normalize</name><displayName>Normalize Table/Column Names</displayName><description>Whether to change characters in column names when creating the output schema. For example, colons and periods will be changed to underscores.</description><defaultValue>false</defaultValue><allowableValues><allowableValue><displayName>true</displayName><value>true</value><description></description></allowableValue><allowableValue><displayName>false</displayName><value>false</value><description></description></allowableValue></allowableValues><required>true</required><sensitive>false</sensitive><expressionLanguageSupported>false</expressionLanguageSupported><expressionLanguageScope>NONE</expressionLanguageScope><dynamicallyModifiesClasspath>false</dynamicallyModifiesClasspath><dynamic>false</dynamic></property><property><name>transaction-isolation-level</name><displayName>Transaction Isolation Level</displayName><description>This setting will set the transaction isolation level for the database connection for drivers that support this setting</description><defaultValue></defaultValue><allowableValues><allowableValue><displayName>TRANSACTION_NONE</displayName><value>0</value><description></description></allowableValue><allowableValue><displayName>TRANSACTION_READ_COMMITTED</displayName><value>2</value><description></description></allowableValue><allowableValue><displayName>TRANSACTION_READ_UNCOMMITTED</displayName><value>1</value><description></description></allowableValue><allowableValue><displayName>TRANSACTION_REPEATABLE_READ</displayName><value>4</value><description></description></allowableValue><allowableValue><displayName>TRANSACTION_SERIALIZABLE</displayName><value>8</value><description></description></allowableValue></allowableValues><required>false</required><sensitive>false</sensitive><expressionLanguageSupported>false</expressionLanguageSupported><expressionLanguageScope>NONE</expressionLanguageScope><dynamicallyModifiesClasspath>false</dynamicallyModifiesClasspath><dynamic>false</dynamic></property><property><name>dbf-user-logical-types</name><displayName>Use Avro Logical Types</displayName><description>Whether to use Avro Logical Types for DECIMAL/NUMBER, DATE, TIME and TIMESTAMP columns. If disabled, written as string. If enabled, Logical types are used and written as its underlying type, specifically, DECIMAL/NUMBER as logical 'decimal': written as bytes with additional precision and scale meta data, DATE as logical 'date-millis': written as int denoting days since Unix epoch (1970-01-01), TIME as logical 'time-millis': written as int denoting milliseconds since Unix epoch, and TIMESTAMP as logical 'timestamp-millis': written as long denoting milliseconds since Unix epoch. If a reader of written Avro records also knows these logical types, then these values can be deserialized with more context depending on reader implementation.</description><defaultValue>false</defaultValue><allowableValues><allowableValue><displayName>true</displayName><value>true</value><description></description></allowableValue><allowableValue><displayName>false</displayName><value>false</value><description></description></allowableValue></allowableValues><required>true</required><sensitive>false</sensitive><expressionLanguageSupported>false</expressionLanguageSupported><expressionLanguageScope>NONE</expressionLanguageScope><dynamicallyModifiesClasspath>false</dynamicallyModifiesClasspath><dynamic>false</dynamic></property><property><name>dbf-default-precision</name><displayName>Default Decimal Precision</displayName><description>When a DECIMAL/NUMBER value is written as a 'decimal' Avro logical type, a specific 'precision' denoting number of available digits is required. Generally, precision is defined by column data type definition or database engines default. However undefined precision (0) can be returned from some database engines. 'Default Decimal Precision' is used when writing those undefined precision numbers.</description><defaultValue>10</defaultValue><allowableValues></allowableValues><required>true</required><sensitive>false</sensitive><expressionLanguageSupported>true</expressionLanguageSupported><expressionLanguageScope>FLOWFILE_ATTRIBUTES</expressionLanguageScope><dynamicallyModifiesClasspath>false</dynamicallyModifiesClasspath><dynamic>false</dynamic></property><property><name>dbf-default-scale</name><displayName>Default Decimal Scale</displayName><description>When a DECIMAL/NUMBER value is written as a 'decimal' Avro logical type, a specific 'scale' denoting number of available decimal digits is required. Generally, scale is defined by column data type definition or database engines default. However when undefined precision (0) is returned, scale can also be uncertain with some database engines. 'Default Decimal Scale' is used when writing those undefined numbers. If a value has more decimals than specified scale, then the value will be rounded-up, e.g. 1.53 becomes 2 with scale 0, and 1.5 with scale 1.</description><defaultValue>0</defaultValue><allowableValues></allowableValues><required>true</required><sensitive>false</sensitive><expressionLanguageSupported>true</expressionLanguageSupported><expressionLanguageScope>FLOWFILE_ATTRIBUTES</expressionLanguageScope><dynamicallyModifiesClasspath>false</dynamicallyModifiesClasspath><dynamic>false</dynamic></property></properties><dynamicProperties><dynamicProperty><name>initial.maxvalue.&lt;max_value_column&gt;</name><value>Initial maximum value for the specified column</value><description>Specifies an initial max value for max value column(s). Properties should be added in the format `initial.maxvalue.&lt;max_value_column&gt;`. This value is only used the first time the table is accessed (when a Maximum Value Column is specified).</description><expressionLanguageSupported>false</expressionLanguageSupported><expressionLanguageScope>VARIABLE_REGISTRY</expressionLanguageScope></dynamicProperty></dynamicProperties><relationships><relationship><name>success</name><description>Successfully created FlowFile from SQL query result set.</description><autoTerminated>false</autoTerminated></relationship></relationships><dynamicRelationship></dynamicRelationship><readsAttributes></readsAttributes><writesAttributes><writesAttribute><name>tablename</name><description>Name of the table being queried</description></writesAttribute><writesAttribute><name>querydbtable.row.count</name><description>The number of rows selected by the query</description></writesAttribute><writesAttribute><name>fragment.identifier</name><description>If 'Max Rows Per Flow File' is set then all FlowFiles from the same query result set will have the same value for the fragment.identifier attribute. This can then be used to correlate the results.</description></writesAttribute><writesAttribute><name>fragment.count</name><description>If 'Max Rows Per Flow File' is set then this is the total number of  FlowFiles produced by a single ResultSet. This can be used in conjunction with the fragment.identifier attribute in order to know how many FlowFiles belonged to the same incoming ResultSet. If Output Batch Size is set, then this attribute will not be populated.</description></writesAttribute><writesAttribute><name>fragment.index</name><description>If 'Max Rows Per Flow File' is set then the position of this FlowFile in the list of outgoing FlowFiles that were all derived from the same result set FlowFile. This can be used in conjunction with the fragment.identifier attribute to know which FlowFiles originated from the same query result set and in what order  FlowFiles were produced</description></writesAttribute><writesAttribute><name>maxvalue.*</name><description>Each attribute contains the observed maximum value of a specified 'Maximum-value Column'. The suffix of the attribute is the name of the column. If Output Batch Size is set, then this attribute will not be populated.</description></writesAttribute></writesAttributes><stateful><description>After performing a query on the specified table, the maximum values for the specified column(s) will be retained for use in future executions of the query. This allows the Processor to fetch only those records that have max values greater than the retained values. This can be used for incremental fetching, fetching of newly added rows, etc. To clear the maximum values, clear the state of the processor per the State Management documentation</description><scopes><scope>CLUSTER</scope></scopes></stateful><restricted></restricted><inputRequirement>INPUT_FORBIDDEN</inputRequirement><systemResourceConsiderations></systemResourceConsiderations><seeAlso/></extension></extensions></extensionManifest>